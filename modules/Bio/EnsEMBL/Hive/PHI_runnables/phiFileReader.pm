=pod 

=head1 NAME

    Bio::EnsEMBL::Hive::PHI_runnables::phiFileReader

=head1 SYNOPSIS

    seed_pipeline.pl -url $EHIVE_URL -logic_name inputfile  -input_id "{'inputfile' => '$HOME/phytopath_dbi/rothamstead_small_version.csv' , 'delimiter' => ',' }"
    
=head1 DESCRIPTION

    This is a generic RunnableDB module for creating batches of similar jobs using dataflow mechanism
    (a fan of jobs is created in one branch and the funnel in another).
    Make sure you wire this buliding block properly from outside.

    You can supply as parameter one of 4 sources of ids from which the batches will be generated:

        param('inputlist');  The list is explicitly given in the parameters, can be abbreviated: 'inputlist' => ['a'..'z']

        param('inputfile');  The list is contained in a file whose name is supplied as parameter: 'inputfile' => 'myfile.txt'

        param('inputquery'); The list is generated by an SQL query (against the production database by default) : 'inputquery' => 'SELECT object_id FROM object WHERE x=y'

        param('inputcmd');   The list is generated by running a system command: 'inputcmd' => 'find /tmp/big_directory -type f'

    NB for developpers: fetch_input() method is intentionally missing from JobFactory.pm .
    If JobFactory is subclassed (say, by a Compara RunnableDB) the child class's should use fetch_input()
    to set $self->param('inputlist') to whatever list of ids specific to that particular type of data (slices, members, etc).
    The rest functionality will be taken care for by the parent class code.

=head1 LICENSE

    Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
    Copyright [2016-2017] EMBL-European Bioinformatics Institute

    Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software distributed under the License
    is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and limitations under the License.

=head1 CONTACT

    Please subscribe to the Hive mailing list:  http://listserver.ebi.ac.uk/mailman/listinfo/ehive-users  to discuss Hive-related questions or to be notified of our updates

=cut


package Bio::EnsEMBL::Hive::PHI_runnables::phiFileReader;

use strict;
use warnings;

use base ('Bio::EnsEMBL::Hive::Process');
use Data::Dumper;
use Bio::EnsEMBL::LookUp::LocalLookUp;
use Scalar::Util qw(looks_like_number);

sub param_defaults {

    return {
        'column_names'      => 0,
        'delimiter'         => ',',
        'key_column'        => 0,
        'input_id'          => 0,   # this parameter is no longer supported and should stay at 0
        'inputfile'         => undef,
        'lookup'            => undef,

        'tax_db_name'       => 'ensembl_compara_master', 
        'tax_db_host'       => 'mysql-eg-pan-prod.ebi.ac.uk',# HOW TO MAKE THIS ONLY DEFAULT? MUST CHANGE IF PROVIDED WITH INPUT ARG!
        'tax_db_port'       => 4276,
        'tax_db_user'       => 'ensro',
        'tax_dba_group'     => 'taxonomy',
        'tax_db_species' => undef,
        'tax_db_pass' => undef,
        'tax_db_driver' => undef,
        'tax_db_species_id' => 1,
        'tax_db_multispecies_db' => 0,

        'MAX_SUB_TAX_DBAS' => 15,

        'fan_branch_code'   => 2,

        'use_bash_pipefail' => 0           # Boolean. When true, the command will be run with "bash -o pipefail -c $cmd". Useful to capture errors in a command that contains pipes
    };
}

sub fetch_input {
    my $self = shift;
    my $inputfile = $self->param_required('inputfile');

    unless (-e $inputfile) {
        die "File $inputfile does not exist"; # Will cause job to fail and leave a message in log_message
    }
}


=head2 run

    Description : Implements run() interface method of Bio::EnsEMBL::Hive::Process that is used to perform the main bulk of the job (minus input and output).

    param('column_names'):  Controls the column names that come out of the parser: 0 = "no names", 1 = "parse names from data", arrayref = "take names from this array"

    param('delimiter'): If you set it your lines in file/cmd mode will be split into columns that you can use individually when constructing the input_id_template hash.

    param('randomize'): Shuffles the rows before creating jobs - can sometimes lead to better overall performance of the pipeline. Doesn't make any sence for minibatches (step>1).

    param('step'):      The requested size of the minibatch (1 by default). The real size of a range may be smaller than the requested size.

    param('contiguous'): Whether the key_column range of each minibatch should be contiguous (0 by default).

    param('key_column'): If every line of your input is a list (it happens, for example, when your SQL returns multiple columns or you have set the 'delimiter' in file/cmd mode)
                         this is the way to say which column is undergoing 'ranging'


        # The following 4 parameters are mutually exclusive and define the source of ids for the jobs:

    param('inputlist');  The list is explicitly given in the parameters, can be abbreviated: 'inputlist' => ['a'..'z']

    param('inputfile');  The list is contained in a file whose name is supplied as parameter: 'inputfile' => 'myfile.txt'

    param('inputquery'); The list is generated by an SQL query (against the production database by default) : 'inputquery' => 'SELECT object_id FROM object WHERE x=y'

    param('inputcmd');   The list is generated by running a system command: 'inputcmd' => 'find /tmp/big_directory -type f'

=cut

sub run {
    my $self = shift @_;

    my $column_names    = $self->param('column_names');   # can be 0 (no names), 1 (names from data) or an arrayref (names from this array)
    my $delimiter       = $self->param('delimiter');
    my $inputfile       = $self->param_required('inputfile');
  
    my ($rows) = $inputfile    ? $self->_get_rows_from_open(  $inputfile  , '<', $delimiter )
            : die "range of values should be defined by setting 'inputfile' ";

    my $output_ids =  $self->_substitute_rows($rows);
    my $lookup = $self->_get_lookup();
    $self->param('lookup', $lookup);
    $self->param('output_ids', $output_ids);
}

=head2 write_output

    Description : Implements write_output() interface method of Bio::EnsEMBL::Hive::Process that is used to deal with job's output after the execution.
                  Here we rely on the dataflow mechanism to create jobs.

    param('fan_branch_code'): defines the branch where the fan of jobs is created (2 by default).

=cut

sub write_output {  # nothing to write out, but some dataflow to perform:
    my $self = shift @_;

    my $output_ids              = $self->param('output_ids');
    my $fan_branch_code         = $self->param('fan_branch_code');
    #Â my $lookup                  = $self->param('lookup');
    # "fan out" into fan_branch_code:
    $self->dataflow_output_id($output_ids, $fan_branch_code);
}


=head2 _get_rows_from_open
    
    Description: a private method that loads rows from a given file into an array. It also performs validation on each line.

=cut

sub _get_rows_from_open {
    my ($self, $input_file_or_command, $open_mode, $delimiter) = @_;


    $self->say_with_header(qq{input_file_or_command = "$input_file_or_command" [$open_mode]\n});
    my @rows = ();
    open(my $fh, $open_mode, $input_file_or_command) or die "Could not open '$input_file_or_command' because: $!";

    LINE: while(my $line = <$fh>) {
        chomp $line;
        $line =~ s/\r//g; 
        my @fields = split( /$delimiter/, $line, -1 );
        
        #validation of the line
        if ( (scalar(@fields) == 15) || (scalar(@fields) == 14 && ($fields[13] eq '' or $fields[14] eq '' )  ) ){ # all fields are complete or all except one of the two publication identifiers
            
            # accept only utf-8 coding entries, discard otherwise
            foreach my $annotation_field (1,2,3,4,6,8) { 
                if ($fields[$annotation_field] =~ /[^\x00-\x7f]/ ) {
                    $self->warning( "The entry " . $fields[1] . " contains one or more non utf-8 coding characters :$fields[$annotation_field]. This entry will be skipped." );
                    next LINE;
                }
            }

            my $annotn_tax_id = $fields[6];

            if ( $annotn_tax_id eq '' || $annotn_tax_id eq 'no data found' || !looks_like_number($annotn_tax_id) || !looks_like_number($fields[0]) || $fields[0] < 0) {
                $self->warning( "The entry '" . $fields[1] . "' has either an empty or non valid Tax id : '$annotn_tax_id', or a non valid phibase_number '" . $fields[0] . "'\n");
                next LINE;
            }

      } else {
        $self->warning( "The entry " . $fields[1] . " contains an abnormal number of delimiters. This entry will be skipped." );
        next LINE;
      }

      push(@rows,[@fields ]); 
      
    }
    close $fh
        or die "Could not read from $open_mode '$input_file_or_command'. Received the error ".($! || $?);

    my $column_names_from_data =  1;
    return (\@rows, $column_names_from_data);
}

=head2 _substitute_rows

    Description: a private method that goes through a list and transforms every row into a hash

=cut

sub _substitute_rows {
    my ($self, $rows) = @_;

    my @hashes = ();

    foreach my $row (@$rows) {
        # my $job_param_hash =  { '_' => $row, map { ("_$_"  => $row->[$_]) } (0..scalar(@$row)-1) };
        my $job_param_hash =  {  map { ("_$_"  => $row->[$_]) } (0..scalar(@$row)-1) };
        push @hashes, $job_param_hash;
    }

    return \@hashes;
}


=head2 _get_lookup
    
    Description: a private method that loads the registry and the lookup taxonomy DB.

=cut

sub _get_lookup {
    my $self = shift @_;
    Bio::EnsEMBL::Registry->load_registry_from_db( 
                         -USER => 'ensro',
                         -HOST => 'mysql-eg-prod-1.ebi.ac.uk',
                         -PORT => 4238);
      
    # my $End = time();
    # my $Diff = $End - $Start;


    # print "time to load registry: $Diff\n";
    # $Start = time();
    
    my $lookup =      
                Bio::EnsEMBL::LookUp::LocalLookUp->new( -SKIP_CONTIGS => 1,
                                                        -NO_CACHE     => 1 ); # Used to check all leafs sub_specie/strains under a taxonomy_id (specie)

    my $tax_dba_details = undef;


    $tax_dba_details->{-GROUP}  = $self->param('tax_dba_group');
    $tax_dba_details->{-DBNAME} = $self->param('tax_db_name');
    $tax_dba_details->{-HOST}   = $self->param('tax_db_host');
    $tax_dba_details->{-PORT}   = $self->param('tax_db_port');
    $tax_dba_details->{-USER}   = $self->param('tax_db_user');

    my $tax_adaptor = Bio::EnsEMBL::DBSQL::TaxonomyNodeAdaptor->new(
                            Bio::EnsEMBL::DBSQL::DBAdaptor->new( %{$tax_dba_details} ) 
                      );
    
    $lookup->taxonomy_adaptor($tax_adaptor);

    return ($lookup);
}

1;
